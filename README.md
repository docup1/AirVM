# Документация виртуальной машины

Данный документ предоставляет подробный обзор реализации виртуальной машины (ВМ). Здесь описывается архитектура, функциональность, набор инструкций, управление памятью и операции ввода-вывода.

---

## Содержание

- [Обзор](#обзор)
- [Возможности](#возможности)
- [Архитектура](#архитектура)
  - [Управление памятью](#управление-памятью)
  - [Регистры и стек](#регистры-и-стек)
  - [Таблица файлов](#таблица-файлов)
- [Набор инструкций](#набор-инструкций)
  - [Управление потоком выполнения](#управление-потоком-выполнения)
  - [Операции с данными](#операции-с-данными)
  - [Арифметические и логические операции](#арифметические-и-логические-операции)
  - [Сравнение](#сравнение)
  - [Ввод-вывод и работа с окружением](#ввод-вывод-и-работа-с-окружением)
  - [Сдвиги и точки останова](#сдвиги-и-точки-остановки)
  - [Снимок и восстановление](#снимок-и-восстановление)
  - [Работа с файлами](#работа-с-файлами)
- [Использование](#использование)
- [Сборка и запуск](#сборка-и-запуск)
- [Обработка ошибок](#обработка-ошибок)
- [Поддержка отладки](#поддержка-отладки)
- [Расширение функционала ВМ](#расширение-функционала-вм)
- [Лицензия](#лицензия)

---

## Обзор

Виртуальная машина представляет собой кастомную платформу для исполнения бинарного файла программы. Она поддерживает широкий набор операций, включая арифметические и логические вычисления, управление потоком выполнения, файловый ввод-вывод и функциональность создания снимка состояния. ВМ реализована на языке C и использует динамически выделяемую память для хранения кода и данных. Ее архитектура легко расширяема благодаря таблице диспетчеризации, связывающей коды операций с их функциями-обработчиками.

---

## Возможности

- **Динамическое управление памятью:** Автоматическое расширение памяти при необходимости.
- **32 регистров общего назначения:** Регистры от R0 до R31.
- **Поддержка стека:** Фиксированный размер стека для хранения адресов возврата и временных данных.
- **Богатый набор инструкций:** Включает арифметические, логические, управляющие, файловые операции и операции ввода-вывода.
- **Работа с файлами:** Базовые операции для открытия, чтения, записи, позиционирования и закрытия файлов.
- **Снимок и восстановление состояния:** Возможность сохранения и восстановления состояния ВМ в/из бинарного файла.
- **Режим отладки:** Возможность включения вывода отладочной информации для отслеживания исполнения программы.

---

## Архитектура

### Управление памятью

- **Выделение памяти:** ВМ начинает работу с начальным размером памяти (64 КБ), определяемым макросом `INIT_MEM_SIZE`, и при необходимости увеличивает ее размер с помощью функции `ensure_memory`.
- **Хранение программы:** Загруженная программа помещается в память ВМ, а размер кода отслеживается переменной `program_size`.

### Регистры и стек

- **Регистры:** ВМ предоставляет 32 регистра (`NUM_REGS`), используемых для общих вычислений.
- **Стек:** Выделенный стек фиксированного размера (`STACK_SIZE`) используется для хранения адресов возврата и временных данных во время вызовов подпрограмм и выполнения операций.

### Таблица файлов

- ВМ поддерживает одновременное открытие до 16 файлов (`MAX_FILES`), которые хранятся в виде массива указателей на `FILE`.

---

## Набор инструкций

ВМ поддерживает широкий спектр опкодов. Каждый опкод представлен константой перечислимого типа и имеет соответствующую функцию для выполнения операции.

### Управление потоком выполнения

- **NOP (`OP_NOP`):** Пустая операция.
- **HALT (`OP_HALT`):** Останавливает выполнение ВМ.
- **JUMP (`OP_JUMP`):** Устанавливает указатель инструкций на заданный адрес.
- **CALL (`OP_CALL`):** Вызывает подпрограмму, сохраняя адрес возврата в стеке.
- **RET (`OP_RET`):** Возвращается из подпрограммы, извлекая адрес возврата из стека.
- **IF (`OP_IF`):** Условный переход в зависимости от заданной маски флагов.

### Операции с данными

- **LOAD (`OP_LOAD`):** Загружает 32-битное значение из памяти в регистр.
- **STORE (`OP_STORE`):** Сохраняет 32-битное значение из регистра в память.
- **MOVE (`OP_MOVE`):** Копирует значение из одного регистра в другой.
- **LOADI (`OP_LOADI`):** Загружает непосредственное 32-битное значение в регистр.
- **PUSH (`OP_PUSH`):** Помещает значение регистра в стек.
- **POP (`OP_POP`):** Извлекает значение из стека в регистр.

### Арифметические и логические операции

- **ADD (`OP_ADD`):** Складывает значения двух регистров.
- **SUB (`OP_SUB`):** Вычитает значение одного регистра из другого.
- **MUL (`OP_MUL`):** Умножает значения двух регистров.
- **DIV (`OP_DIV`):** Делит значение одного регистра на другое (с проверкой деления на ноль).
- **AND (`OP_AND`):** Выполняет побитовое И над значениями двух регистров.
- **OR (`OP_OR`):** Выполняет побитовое ИЛИ над значениями двух регистров.
- **XOR (`OP_XOR`):** Выполняет побитовое исключающее ИЛИ над значениями двух регистров.
- **NOT (`OP_NOT`):** Выполняет побитовое отрицание значения регистра.

### Сравнение

- **CMP (`OP_CMP`):** Сравнивает значение регистра с непосредственным значением. Регистр флагов устанавливается следующим образом:
  - **0x01:** Равны
  - **0x02:** Меньше
  - **0x04:** Больше

### Ввод-вывод и работа с окружением

- **FS_LIST (`OP_FS_LIST`):** Выводит список файлов в текущей директории и сохраняет результат в памяти в виде строки.
- **ENV_LIST (`OP_ENV_LIST`):** Выводит список переменных окружения и сохраняет их в памяти.
- **PRINT (`OP_PRINT`):** Выводит значение регистра на стандартный вывод.
- **PRINTS (`OP_PRINTS`):** Выводит нуль-терминированную строку, хранящуюся в памяти.
- **INPUT (`OP_INPUT`):** Считывает целое число со стандартного ввода и сохраняет его в регистр.

### Сдвиги и точки останова

- **SHL (`OP_SHL`):** Сдвигает значение регистра влево.
- **SHR (`OP_SHR`):** Сдвигает значение регистра вправо.
- **BREAK (`OP_BREAK`):** Приостанавливает выполнение для целей отладки.

### Снимок и восстановление

- **SNAPSHOT (`OP_SNAPSHOT`):** Сохраняет текущее состояние ВМ (регистры, стек, память и т.д.) в файл (`snapshot.bin`).
- **RESTORE (`OP_RESTORE`):** Восстанавливает состояние ВМ из файла снимка. Обратите внимание, что указатели на файлы не восстанавливаются.

### Работа с файлами

- **FILE_OPEN (`OP_FILE_OPEN`):** Открывает файл с заданным именем и режимом, сохраняет дескриптор файла в регистр.
- **FILE_READ (`OP_FILE_READ`):** Читает данные из открытого файла в память.
- **FILE_WRITE (`OP_FILE_WRITE`):** Записывает данные из памяти в открытый файл.
- **FILE_CLOSE (`OP_FILE_CLOSE`):** Закрывает открытый файл.
- **FILE_SEEK (`OP_FILE_SEEK`):** Перемещает указатель позиции в открытом файле на заданную позицию.

---

## Использование

### Загрузка программы

- ВМ ожидает в качестве аргумента бинарный файл программы.
- Первые 4 байта файла указывают размер секции кода.
- Код загружается в память и выполняется с адреса 0.

### Пример запуска

```bash
./vm program.bin
```

При успешной загрузке ВМ выводит количество загруженных байт, после чего начинает выполнение программы. По завершении исполнения выводится общее время выполнения.

---

## Сборка и запуск

### Компиляция

Скомпилируйте ВМ с помощью компилятора C (например, `gcc`):

```bash
gcc -o vm vm.c
```

### Запуск ВМ

Запустите исполняемый файл, передав в качестве аргумента файл программы:

```bash
./vm program.bin
```

Если файл не указан, ВМ выведет инструкцию по использованию.

---

## Обработка ошибок

- **Ошибки памяти:** ВМ проверяет выход за пределы выделенной памяти и ошибки при выделении памяти. При возникновении ошибки выводится сообщение, и выполнение прерывается.
- **Неверные операции:** Попытки обращения к несуществующему регистру, переход по неверному адресу или деление на ноль приводят к возникновению ошибки.
- **Файловый ввод-вывод:** Ошибки при операциях с файлами (открытие, чтение, запись, позиционирование) обрабатываются и выводятся соответствующие сообщения.

---

## Поддержка отладки

- **Режим отладки:** При включении режима отладки (флаг `vm.debug`) ВМ выводит внутреннее состояние (указатель инструкций, указатель стека, флаги и значения регистров) после каждой выполненной инструкции.
- **Точки останова:** Инструкция `OP_BREAK` позволяет вручную приостанавливать выполнение программы для анализа текущего состояния.

---

## Расширение функционала ВМ

Архитектура ВМ основана на таблице диспетчеризации, связывающей опкоды с их функциями-обработчиками. Для добавления новых инструкций:
1. Добавьте новый опкод в перечисление `Opcode`.
2. Реализуйте функционал инструкции в виде функции с сигнатурой `void op_new(VM *vm)`.
3. Зарегистрируйте новый опкод в таблице диспетчеризации в функции `init_dispatch_table`.

---

## Лицензия

*Данная виртуальная машина предоставляется под открытой лицензией. Подробности см. в файле LICENSE проекта.*

---

Эта документация предоставляет исчерпывающую информацию для понимания и работы с виртуальной машиной. Если у вас возникнут вопросы или предложения по улучшению, пожалуйста, обратитесь к репозиторию проекта или свяжитесь с командой разработчиков.
