# Документация виртуальной машины (VM)

## Описание
Данная виртуальная машина представляет собой простой интерпретатор байт-кода, написанный на языке C. Она предназначена для выполнения программ, загруженных в виде бинарных файлов. VM поддерживает базовые арифметические, логические операции, управление потоком выполнения, работу со стеком, ввод-вывод, а также взаимодействие с файловой системой и переменными окружения.

---

## Архитектура

### Память
- **Размер памяти**: 64 КБ (`MEM_SIZE = 65536 байт`).
- Используется для хранения байт-кода программы и данных.
- Адресация: 32-битная (4 байта на адрес).

### Регистры
- **Количество регистров**: 8 (`NUM_REGS = 8`), обозначены как `R0`–`R7`.
- Каждый регистр — 32-битный (`uint32_t`).

### Стек
- **Размер стека**: 1024 элемента (`STACK_SIZE = 1024`).
- Каждый элемент — 32-битный (`uint32_t`).
- Указатель стека (`sp`) указывает на следующую свободную позицию.

### Указатель инструкций
- **IP** (`ip`): 32-битный указатель текущей инструкции в памяти.

### Флаги
- **Flags** (`flags`): 8-битное поле для хранения результатов сравнения:
  - `0x01`: равно (equal).
  - `0x02`: меньше (less).
  - `0x04`: больше (greater).

### Структура VM
```c
typedef struct {
    uint8_t memory[MEM_SIZE];      // Память
    uint32_t registers[NUM_REGS];  // Регистры
    uint32_t stack[STACK_SIZE];    // Стек
    uint32_t sp;                   // Указатель стека
    uint32_t ip;                   // Указатель инструкций
    uint8_t flags;                 // Флаги
    int running;                   // Флаг выполнения
    uint32_t program_size;         // Размер программы
} VM;
```
---

## Поддерживаемые операции

### Управление выполнением
| Код      | Операция     | Описание                                   | Формат                         |
|----------|--------------|--------------------------------------------|--------------------------------|
| `0x00`   | `NOP`        | Нет операции (пустая инструкция).          | `NOP`                          |
| `0x01`   | `HALT`       | Остановка выполнения программы.            | `HALT`                         |
| `0x02`   | `JUMP`       | Безусловный переход на адрес.              | `JUMP addr` (4 байта)          |
| `0x03`   | `CALL`       | Вызов подпрограммы (сохраняет IP в стек).   | `CALL addr` (4 байта)          |
| `0x04`   | `RET`        | Возврат из подпрограммы (извлекает IP).    | `RET`                          |
| `0x05`   | `IF`         | Условный переход по флагам.                | `IF mask addr` (1 + 4 байта)   |

- **IF**: Переход на `addr`, если `(flags & mask) != 0`.

### Работа с памятью и регистрами
| Код      | Операция     | Описание                                   | Формат                         |
|----------|--------------|--------------------------------------------|--------------------------------|
| `0x10`   | `LOAD`       | Загрузка из памяти в регистр.              | `LOAD reg addr` (1 + 4 байта)  |
| `0x11`   | `STORE`      | Сохранение из регистра в память.           | `STORE reg addr` (1 + 4 байта) |
| `0x12`   | `MOVE`       | Копирование значения между регистрами.     | `MOVE dest src` (2 байта)      |
| `0x13`   | `PUSH`       | Помещение значения регистра в стек.        | `PUSH reg` (1 байт)            |
| `0x14`   | `POP`        | Извлечение значения из стека в регистр.    | `POP reg` (1 байт)             |

### Арифметические и логические операции
| Код      | Операция     | Описание                                   | Формат                         |
|----------|--------------|--------------------------------------------|--------------------------------|
| `0x20`   | `ADD`        | Сложение: `dest = reg1 + reg2`.            | `ADD dest reg1 reg2` (3 байта) |
| `0x21`   | `SUB`        | Вычитание: `dest = reg1 - reg2`.           | `SUB dest reg1 reg2` (3 байта) |
| `0x22`   | `MUL`        | Умножение: `dest = reg1 * reg2`.           | `MUL dest reg1 reg2` (3 байта) |
| `0x23`   | `DIV`        | Деление: `dest = reg1 / reg2`.             | `DIV dest reg1 reg2` (3 байта) |
| `0x24`   | `AND`        | Побитовое И: `dest = reg1 & reg2`.         | `AND dest reg1 reg2` (3 байта) |
| `0x25`   | `OR`         | Побитовое ИЛИ: `dest = reg1 \| reg2`.       | `OR dest reg1 reg2` (3 байта)  |
| `0x26`   | `XOR`        | Побитовое XOR: `dest = reg1 ^ reg2`.       | `XOR dest reg1 reg2` (3 байта) |
| `0x27`   | `NOT`        | Побитовое НЕ: `dest = ~reg`.               | `NOT dest reg` (2 байта)       |
| `0x28`   | `CMP`        | Сравнение `reg1` и `reg2`, установка флагов.| `CMP reg1 reg2` (2 байта)      |

- **CMP**: Устанавливает флаги:
  - `0x01` (равно), если `reg1 == reg2`.
  - `0x02` (меньше), если `reg1 < reg2`.
  - `0x04` (больше), если `reg1 > reg2`.

### Взаимодействие с системой
| Код      | Операция     | Описание                                   | Формат                         |
|----------|--------------|--------------------------------------------|--------------------------------|
| `0x34`   | `FS_LIST`    | Список файлов текущей директории в память. | `FS_LIST addr` (4 байта)       |
| `0x42`   | `ENV_LIST`   | Список переменных окружения в память.      | `ENV_LIST addr` (4 байта)      |
| `0x50`   | `PRINT`      | Вывод значения регистра на экран.          | `PRINT reg` (1 байт)           |
| `0x51`   | `INPUT`      | Ввод числа с клавиатуры в регистр.         | `INPUT reg` (1 байт)           |

- **FS_LIST**: Записывает список файлов в память по адресу `addr` как строку с разделителями `\n`.
- **ENV_LIST**: Записывает переменные окружения в память по адресу `addr` как строку с разделителями `\n`.

---

## Пример использования

### Компиляция и запуск
1. Скомпилируйте код:
   ```bash
   gcc vm.c -o vm
   ```
2. Подготовьте программу в виде бинарного файла (например, `program.bin`).
   ```bash
   printf "\x10\x00\x10\x00\x00\x00\x00\x00\x00\x00\x50\x00\x00\x00\x00\x01\x2A\x00\x00\x00" > program.bin
   ```
4. Запустите VM с программой:
   ```bash
   ./vm program.bin
   ```

### Пример программы
Программа, которая складывает два числа, введённых пользователем:
1. `INPUT R0` — ввод первого числа в `R0`.
2. `INPUT R1` — ввод второго числа в `R1`.
3. `ADD R2 R0 R1` — сложение `R0 + R1`, результат в `R2`.
4. `PRINT R2` — вывод результата.
5. `HALT` — остановка.

Бинарный вид:
```
0x51 0x00          ; INPUT R0
0x51 0x01          ; INPUT R1
0x20 0x02 0x00 0x01 ; ADD R2 R0 R1
0x50 0x02          ; PRINT R2
0x01               ; HALT
```

---

## Ограничения
- Размер программы не должен превышать 64 КБ.
- Стек ограничен 1024 элементами.
- Нет поддержки вещественных чисел.
- Ошибки (например, деление на ноль, переполнение стека) останавливают выполнение с выводом сообщения.

---

## Ошибки и диагностика
VM выводит сообщения об ошибках в следующих случаях:
- Переполнение стека (`Stack overflow`).
- Недостаток данных в стеке (`Stack underflow`).
- Выход за пределы памяти (`out of bounds`).
- Деление на ноль (`Division by zero`).
- Неизвестный код операции (`Unknown opcode`).

---

## Расширяемость
- Можно добавить новые операции, расширив таблицу кодов в `vm_run`.
- Поддержка дополнительных типов данных (например, строки или float) потребует изменения структуры регистров и памяти.

---

